import{defineComponent as e,computed as t,h as a,onServerPrefetch as r,toValue as n,getCurrentInstance as o,ref as s,shallowRef as i,toRef as u,nextTick as c,unref as l}from"vue";import{Icon as d,getIcon as p,loadIcon as m}from"@iconify/vue";import{getIconCSS as f}from"@iconify/utils/lib/css/icon";import{A as y,Q as v,B as h,g as _,O as b,P as D}from"./server.mjs";import"../_/nitro.mjs";import"node:http";import"node:https";import"node:events";import"node:buffer";import"node:fs";import"node:url";import"@iconify/utils";import"node:crypto";import"consola";import"node:path";import"pinia";import"vue-router";import"@css-render/vue3-ssr";import"vue/server-renderer";import"seemly";import"@css-render/plugin-bem";import"css-render";import"lodash-es";import"evtd";import"../routes/renderer.mjs";import"vue-bundle-renderer/runtime";import"unhead/server";import"devalue";import"unhead/plugins";import"unhead/utils";const g={trailing:!0};function debounce(e,t=25,a={}){if(a={...g,...a},!Number.isFinite(t))throw new TypeError("Expected `wait` to be a finite number");let r,n,o,s,i=[];const applyFn=(t,r)=>(o=async function(e,t,a){return await e.apply(t,a)}(e,t,r),o.finally(()=>{if(o=null,a.trailing&&s&&!n){const e=applyFn(t,s);return s=null,e}}),o),debounced=function(...e){return a.trailing&&(s=e),o||new Promise(o=>{const u=!n&&a.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const t=a.leading?r:applyFn(this,e);s=null;for(const e of i)e(t);i=[]},t),u?(r=applyFn(this,e),o(r)):i.push(o)})},_clearTimeout=e=>{e&&(clearTimeout(e),n=null)};return debounced.isPending=()=>!!n,debounced.cancel=()=>{_clearTimeout(n),i=[],s=null},debounced.flush=()=>{if(_clearTimeout(n),!s||o)return;const e=s;return s=null,applyFn(this,e)},debounced}function useAsyncData(...e){const a="string"==typeof e[e.length-1]?e.pop():void 0;(function(e,t){if("string"==typeof e)return!1;if("object"==typeof e&&null!==e)return!1;if("function"==typeof e&&"function"==typeof t)return!1;return!0})(e[0],e[1])&&e.unshift(a);let[d,p,m={}]=e;const f=t(()=>n(d));if("string"!=typeof f.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof p)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const v=y();function createInitialFetch(){const e={cause:"initial",dedupe:m.dedupe};return v._asyncData[f.value]?._init||(e.cachedData=m.getCachedData(f.value,v,{cause:"initial"}),v._asyncData[f.value]=function(e,a,r,n,o){e.payload._errors[a]??=void 0;const d=n.getCachedData!==getDefaultCachedData,p=r,m=n.deep?s:i,f=void 0!==o,y=e.hook("app:data:refresh",async e=>{e&&!e.includes(a)||await v.execute({cause:"refresh:hook"})}),v={data:m(f?o:n.default()),pending:t(()=>"pending"===v.status.value),error:u(e.payload._errors,a),status:i("idle"),execute:(...t)=>{const[r,o]=t,s=r&&void 0===o&&"object"==typeof r?r:{};if(e._asyncDataPromises[a]&&"defer"===(s.dedupe??n.dedupe))return e._asyncDataPromises[a];{const t="cachedData"in s?s.cachedData:n.getCachedData(a,e,{cause:s.cause??"refresh:manual"});if(void 0!==t)return e.payload.data[a]=v.data.value=t,v.error.value=void 0,v.status.value="success",Promise.resolve(t)}v._abortController&&v._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),v._abortController=new AbortController,v.status.value="pending";const i=new AbortController,u=new Promise((t,a)=>{try{const r=s.timeout??n.timeout,o=function(e,t,a){const r=e.filter(e=>!!e);if("number"==typeof a&&a>=0){const e=AbortSignal.timeout?.(a);e&&r.push(e)}if(AbortSignal.any)return AbortSignal.any(r);const n=new AbortController;for(const e of r)if(e.aborted){const t=e.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}return n.signal}const onAbort=()=>{const e=r.find(e=>e.aborted),t=e?.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}};for(const e of r)e.addEventListener?.("abort",onAbort,{once:!0,signal:t});return n.signal}([v._abortController?.signal,s?.signal],i.signal,r);if(o.aborted){const e=o.reason;return void a(e instanceof Error?e:new DOMException(String(e??"Aborted"),"AbortError"))}return o.addEventListener("abort",()=>{const e=o.reason;a(e instanceof Error?e:new DOMException(String(e??"Aborted"),"AbortError"))},{once:!0,signal:i.signal}),Promise.resolve(p(e,{signal:o})).then(t,a)}catch(e){a(e)}}).then(async t=>{let r=t;n.transform&&(r=await n.transform(t)),n.pick&&(r=function(e,t){const a={};for(const r of t)a[r]=e[r];return a}(r,n.pick)),e.payload.data[a]=r,v.data.value=r,v.error.value=void 0,v.status.value="success"}).catch(t=>e._asyncDataPromises[a]&&e._asyncDataPromises[a]!==u||v._abortController?.signal.aborted?e._asyncDataPromises[a]:"undefined"!=typeof DOMException&&t instanceof DOMException&&"AbortError"===t.name?(v.status.value="idle",e._asyncDataPromises[a]):(v.error.value=D(t),v.data.value=l(n.default()),void(v.status.value="error"))).finally(()=>{i.abort(),delete e._asyncDataPromises[a]});return e._asyncDataPromises[a]=u,e._asyncDataPromises[a]},_execute:debounce((...e)=>v.execute(...e),0,{leading:!0}),_default:n.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{y(),e._asyncData[a]?._init&&(e._asyncData[a]._init=!1),d||c(()=>{e._asyncData[a]?._init||(clearNuxtDataByKey(e,a),v.execute=()=>Promise.resolve())})}};return v}(v,f.value,p,m,e.cachedData)),()=>v._asyncData[f.value].execute(e)}m.server??=!0,m.default??=getDefault,m.getCachedData??=getDefaultCachedData,m.lazy??=!1,m.immediate??=!0,m.deep??=b.deep,m.dedupe??="cancel",m._functionName,v._asyncData[f.value];const h=createInitialFetch();v._asyncData[f.value]._deps++;if(!1!==m.server&&v.payload.serverRendered&&m.immediate){const e=h();o()?r(()=>e):v.hook("app:created",async()=>{await e})}const _={data:writableComputedRef(()=>v._asyncData[f.value]?.data),pending:writableComputedRef(()=>v._asyncData[f.value]?.pending),status:writableComputedRef(()=>v._asyncData[f.value]?.status),error:writableComputedRef(()=>v._asyncData[f.value]?.error),refresh:(...e)=>{if(!v._asyncData[f.value]?._init){return createInitialFetch()()}return v._asyncData[f.value].execute(...e)},execute:(...e)=>_.refresh(...e),clear:()=>{const e=v._asyncData[f.value];if(e?._abortController)try{e._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{e._abortController=void 0}clearNuxtDataByKey(v,f.value)}},g=Promise.resolve(v._asyncDataPromises[f.value]).then(()=>_);return Object.assign(g,_),g}function writableComputedRef(e){return t({get:()=>e()?.value,set(t){const a=e();a&&(a.value=t)}})}function clearNuxtDataByKey(e,t){t in e.payload.data&&(e.payload.data[t]=void 0),t in e.payload._errors&&(e.payload._errors[t]=void 0),e._asyncData[t]&&(e._asyncData[t].data.value=l(e._asyncData[t]._default()),e._asyncData[t].error.value=void 0,e._asyncData[t].status.value="idle"),t in e._asyncDataPromises&&(e._asyncDataPromises[t]=void 0)}const getDefault=()=>{},getDefaultCachedData=(e,t,a)=>t.isHydrating?t.payload.data[e]:"refresh:manual"!==a.cause&&"refresh:hook"!==a.cause?t.static.data[e]:void 0;async function loadIcon(e,t){if(!e)return null;const a=p(e);if(a)return a;let r;const n=m(e).catch(()=>(console.warn(`[Icon] failed to load icon \`${e}\``),null));return t>0?await Promise.race([n,new Promise(a=>{r=setTimeout(()=>{console.warn(`[Icon] loading icon \`${e}\` timed out after ${t}ms`),a()},t)})]).finally(()=>clearTimeout(r)):await n,p(e)}function useResolvedName(e){const a=v().icon,r=(a.collections||[]).sort((e,t)=>t.length-e.length);return t(()=>{const t=e(),n=t.startsWith(a.cssSelectorPrefix)?t.slice(a.cssSelectorPrefix.length):t,o=a.aliases?.[n]||n;if(!o.includes(":")){const e=r.find(e=>o.startsWith(e+"-"));return e?e+":"+o.slice(e.length+1):o}return o})}function resolveCustomizeFn(e,t){if(!1!==e)return!0===e||null===e?t:e}const w="NUXT_ICONS_SERVER_CSS";const x=e({name:"NuxtIconCss",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e){const n=y(),o=v().icon,s=t(()=>e.name?o.cssSelectorPrefix+e.name:""),i=t(()=>"."+function(e){return e.replace(/([^\w-])/g,"\\$1")}(s.value));return r(async()=>{{const t=h().icon||{};if(!t?.serverKnownCssClasses?.includes(s.value)){const t=await loadIcon(e.name,o.fetchTimeout).catch(()=>null);if(!t)return null;let a=n.vueApp._context.provides[w];if(a||(a=n.vueApp._context.provides[w]=new Map,n.runWithContext(()=>{_({style:[()=>{let e=Array.from(a.values()).sort().join("");return o.cssLayer&&(e=`@layer ${o.cssLayer} {${e}}`),{innerHTML:e}}]},{tagPriority:"low"})})),e.name&&!a.has(e.name)){const r=function(t,a=!0){let r=i.value;o.cssWherePseudo&&(r=`:where(${r})`);const n=f(t,{iconSelector:r,format:"compressed",customise:resolveCustomizeFn(e.customize,o.customize)});return o.cssLayer&&a?`@layer ${o.cssLayer} { ${n} }`:n}(t,!1);a.set(e.name,r)}return null}}}),()=>a("span",{class:["iconify",s.value]})}}),C=e({name:"NuxtIconSvg",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e,{slots:t}){y();const n=v().icon,o=useResolvedName(()=>e.name),s="i-"+o.value;return o.value&&r(async()=>{await useAsyncData(s,async()=>await loadIcon(o.value,n.fetchTimeout),{deep:!1})}),()=>a(d,{icon:o.value,ssr:!0,customise:resolveCustomizeFn(e.customize,n.customize)},t)}}),A=e({name:"NuxtIcon",props:{name:{type:String,required:!0},mode:{type:String,required:!1,default:null},size:{type:[Number,String],required:!1,default:null},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e,{slots:r}){const n=y(),o=v().icon,s=useResolvedName(()=>e.name),i=t(()=>n.vueApp?.component(s.value)||("svg"===(e.mode||o.mode)?C:x)),u=t(()=>{const t=e.size||o.size;return t?{fontSize:Number.isNaN(+t)?t:t+"px"}:null});return()=>a(i.value,{...o.attrs,name:s.value,class:o.class,style:u.value,customize:e.customize},r)}});export{A as default};
//# sourceMappingURL=index-AgLHWp8z.mjs.map
